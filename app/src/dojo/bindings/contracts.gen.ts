// Generated by dojo-bindgen on Thu, 10 Oct 2024 16:11:03 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript`
import { Account, byteArray } from "starknet";
import { DojoProvider, getContractByName } from "@dojoengine/core";
import * as models from "./models.gen";
import { dojoConfig } from "../../../dojo.config";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `paved-Account` contract
  function Account() {
    const contract_name = "Account";
    const fee_token_name = "Token";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };

    // Call the `create` system with the specified Account and calldata
    const create = async (props: { account: Account; name: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "mint",
              calldata: [],
            },
            {
              contractName: contract_name,
              entrypoint: "create",
              calldata: [props.name],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing create:", error);
        throw error;
      }
    };

    return {
      world,
      name,
      create,
    };
  }

  // System definitions for `paved-Daily` contract
  function Daily() {
    const config = dojoConfig();
    const contract_name = "Daily";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: {
      account: Account;
      tournament_id: number;
      rank: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.tournament_id, props.rank],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };

    // Call the `sponsor` system with the specified Account and calldata
    const sponsor = async (props: { account: Account; amount: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractAddress: config.feeTokenAddress,
              entrypoint: "approve",
              calldata: [contract_address, props.amount, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "sponsor",
              calldata: [props.amount],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing sponsor:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: {
      account: Account;
      game_id: number;
      orientation: number;
      x: number;
      y: number;
      role: number;
      spot: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [
              props.game_id,
              props.orientation,
              props.x,
              props.y,
              props.role,
              props.spot,
            ],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    return {
      name,
      world,
      spawn,
      claim,
      sponsor,
      discard,
      surrender,
      build,
    };
  }

  // System definitions for `paved-Duel` contract
  function Duel() {
    const config = dojoConfig();
    const contract_name = "Duel";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: {
      account: Account;
      name: bigint;
      duration: number;
      price: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [
                contract_address,
                `0x${props.price.toString(16)}`,
                "0x0",
              ],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [props.name, props.duration, props.price],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `rename` system with the specified Account and calldata
    const rename = async (props: {
      account: Account;
      game_id: number;
      name: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "rename",
            calldata: [props.game_id, props.name],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing rename:", error);
        throw error;
      }
    };

    // Call the `update` system with the specified Account and calldata
    const update = async (props: {
      account: Account;
      game_id: number;
      duration: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "update",
            calldata: [props.game_id, props.duration],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing update:", error);
        throw error;
      }
    };

    // Call the `join` system with the specified Account and calldata
    const join = async (props: { account: Account; game_id: number, amount: number }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(props.amount * 1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "join",
              calldata: [props.game_id],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing join:", error);
        throw error;
      }
    };

    // Call the `ready` system with the specified Account and calldata
    const ready = async (props: {
      account: Account;
      game_id: number;
      status: boolean;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "ready",
            calldata: [props.game_id, props.status],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing ready:", error);
        throw error;
      }
    };

    // Call the `transfer` system with the specified Account and calldata
    const transfer = async (props: {
      account: Account;
      game_id: number;
      player_id: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer",
            calldata: [props.game_id, props.player_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing transfer:", error);
        throw error;
      }
    };

    // Call the `leave` system with the specified Account and calldata
    const leave = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "leave",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing leave:", error);
        throw error;
      }
    };

    // Call the `kick` system with the specified Account and calldata
    const kick = async (props: {
      account: Account;
      game_id: number;
      player_id: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "kick",
            calldata: [props.game_id, props.player_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing kick:", error);
        throw error;
      }
    };

    // Call the `delete` system with the specified Account and calldata
    const remove = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "delete",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing delete:", error);
        throw error;
      }
    };

    // Call the `start` system with the specified Account and calldata
    const start = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "start",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing start:", error);
        throw error;
      }
    };

    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: {
      account: Account;
      game_id: number;
      orientation: number;
      x: number;
      y: number;
      role: number;
      spot: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [
              props.game_id,
              props.orientation,
              props.x,
              props.y,
              props.role,
              props.spot,
            ],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    return {
      spawn,
      rename,
      update,
      join,
      ready,
      transfer,
      leave,
      kick,
      remove,
      start,
      claim,
      discard,
      build,
      name,
      world,
    };
  }

  // System definitions for `paved-Tutorial` contract
  function Tutorial() {
    const config = dojoConfig();
    const contract_name = "Tutorial";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "spawn",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    return {
      world,
      name,
      spawn,
      discard,
      surrender,
      build,
    };
  }

  // System definitions for `paved-Weekly` contract
  function Weekly() {
    const config = dojoConfig();
    const contract_name = "Weekly";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: {
      account: Account;
      tournament_id: number;
      rank: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.tournament_id, props.rank],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };

    // Call the `sponsor` system with the specified Account and calldata
    const sponsor = async (props: { account: Account; amount: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, props.amount, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "sponsor",
              calldata: [props.amount],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing sponsor:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: {
      account: Account;
      game_id: number;
      orientation: number;
      x: number;
      y: number;
      role: number;
      spot: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [
              props.game_id,
              props.orientation,
              props.x,
              props.y,
              props.role,
              props.spot,
            ],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    return {
      name,
      world,
      spawn,
      claim,
      sponsor,
      discard,
      surrender,
      build,
    };
  }

  return {
    Account: Account(),
    Daily: Daily(),
    Duel: Duel(),
    Tutorial: Tutorial(),
    Weekly: Weekly(),
  };
}
